{
  "version": 3,
  "sources": ["../../node_modules/radio-browser-api/src/constants.ts", "../../node_modules/radio-browser-api/src/radioBrowser.ts"],
  "sourcesContent": ["/**\n * @public\n */\nexport const StationSearchOrder = {\n  name: 'name',\n  url: 'url',\n  homepage: 'homepage',\n  favicon: 'favicon',\n  tags: 'tags',\n  country: 'country',\n  state: 'state',\n  language: 'language',\n  votes: 'votes',\n  codec: 'codec',\n  bitrate: 'bitrate',\n  lastCheckOK: 'lastCheckOK',\n  lastCheckTime: 'lastCheckTime',\n  clickTimeStamp: 'clickTimeStamp',\n  clickCount: 'clickCount',\n  clickTrend: 'clickTrend',\n  random: 'random'\n} as const\n\n/**\n * @public\n */\nexport const StationSearchType = {\n  byUuid: 'byUuid',\n  byName: 'byName',\n  byNameExact: 'byNameExact',\n  byCodec: 'byCodec',\n  byCodexExact: 'byCodecExact',\n  byCountry: 'byCountry',\n  byCountryExact: 'byCountryExact',\n  byCountryCodeExact: 'byCountryCodeExact',\n  byState: 'byState',\n  byStateExact: 'byStateExact',\n  byLanguage: 'byLanguage',\n  byLanguageExact: 'byLanguageExact',\n  byTag: 'byTag',\n  byTagExact: 'byTagExact'\n} as const\n\n/**\n * @public\n */\nexport type StationResponse = {\n  changeuuid: string\n  stationuuid: string\n  name: string\n  url: string\n  url_resolved: string\n  homepage: string\n  favicon: string\n  tags: string\n  country: string\n  countrycode: string\n  state: string\n  language: string\n  votes: number\n  lastchangetime: string\n  codec: string\n  bitrate: number\n  hls: number\n  lastcheckok: number\n  lastchecktime: string\n  lastlocalchecktime: string\n  lastcheckoktime: string\n  clicktimestamp: string\n  clickcount: number\n  clicktrend: number\n  geo_lat?: number | null\n  geo_long?: number | null\n}\n\n/**\n * @public\n */\nexport type Station = {\n  changeId: string\n  id: string\n  name: string\n  url: string\n  urlResolved: string\n  homepage: string\n  favicon: string\n  tags: string[]\n  country: string\n  countryCode: string\n  state: string\n  language: string[]\n  votes: number\n  lastChangeTime: Date\n  codec: string\n  bitrate: number\n  hls: boolean\n  lastCheckOk: boolean\n  lastCheckTime: Date\n  lastCheckOkTime: Date\n  lastLocalCheckTime: Date\n  clickTimestamp: Date\n  clickCount: number\n  clickTrend: number\n  geoLat?: number | null\n  geoLong?: number | null\n}\n\n/**\n * @public\n */\nexport type StationQuery = {\n  offset?: number\n  limit?: number\n  reverse?: boolean\n  order?: keyof typeof StationSearchOrder\n  hideBroken?: boolean\n  removeDuplicates?: boolean\n}\n\n/**\n * @public\n */\nexport type AdvancedStationQuery = {\n  name?: string\n  nameExact?: boolean\n  country?: string\n  countryExact?: boolean\n  countryCode?: string\n  state?: string\n  stateExact?: boolean\n  language?: string\n  languageExact?: boolean\n  tag?: string\n  tagExact?: boolean\n  tagList?: string[]\n  codec?: string\n  bitrateMin?: string\n  bitrateMax?: string\n  hasGeoInfo?: boolean\n} & StationQuery\n\n/**\n * @public\n */\nexport type Query = {\n  order?: 'name' | 'stationcount'\n  reverse?: boolean\n  hideBroken?: boolean\n} & Record<string, any>\n\n// valid for country codes also\n/**\n * @public\n */\nexport type CountryResult = {\n  name: string\n  stationcount: number\n}\n\n/**\n * @public\n */\nexport type TagResult = CountryResult\n/**\n * @public\n */\nexport type CountryStateResult = CountryResult & {\n  country: string\n}\n", "import {\n  StationSearchType,\n  AdvancedStationQuery,\n  CountryResult,\n  CountryStateResult,\n  Query,\n  Station,\n  StationQuery,\n  StationResponse,\n  TagResult\n} from './constants'\n\n/**\n * Query the radio browser api.\n * @public\n */\nexport class RadioBrowserApi {\n  static version = __VERSION__\n\n  protected baseUrl: string | undefined\n\n  protected fetchConfig: RequestInit = {\n    method: 'GET',\n    redirect: 'follow'\n  }\n\n  /**\n   * Creates an instance of radio browser api.\n   * @param appName - App name to be used as user agent header to indentify the calls to the API\n   * @param hideBroken - Hide broken stations for all future API calls\n   */\n  constructor(protected appName: string, protected hideBroken = true) {\n    if (!appName) {\n      throw new Error('appName is required')\n    }\n    this.fetchConfig.headers = { 'user-agent': this.appName }\n  }\n\n  /**\n   * Resolves API base url this will be the default for all class instances.\n   * @param autoSet - Automatically set first resolved base url\n   * @param config-  Fetch configuration\n   * @returns Array of objects with the ip and name of the api server\n   */\n  async resolveBaseUrl(\n    config: RequestInit = {}\n  ): Promise<{ ip: string; name: string }[]> {\n    let result: { ip: string; name: string }[]\n\n    // temporary fix for https cert error when in frontend\n    // hardcode the server\n    // https://github.com/segler-alex/radiobrowser-api-rust/issues/122\n    // if (typeof window !== 'undefined') {\n    //   return [{ ip: '45.77.62.161', name: 'fr1.api.radio-browser.info' }]\n    // }\n    const response = await fetch(\n      // this should be https when the above issue is resolved\n      'http://all.api.radio-browser.info/json/servers',\n      config\n    )\n    if (response.ok) {\n      result = await response.json()\n\n      return result\n    } else {\n      throw response\n    }\n  }\n\n  /**\n   * Sets base url for all api calls\n   * @param url - Url to the api server\n   */\n  setBaseUrl(url: string): void {\n    this.baseUrl = url\n  }\n\n  /**\n   * Get current  base url\n   * @returns Base url\n   */\n  getBaseUrl(): string | undefined {\n    return this.baseUrl\n  }\n\n  /**\n   * Gets available countries\n   * @param search - Search for country\n   * @param query - Query params\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of country results with the name of the station and station count\n   */\n  async getCountries(\n    search?: string,\n    query?: Query,\n    fetchConfig?: RequestInit\n  ): Promise<CountryResult[]> {\n    return this.runRequest(\n      this.buildRequest('countries', search, query),\n      fetchConfig\n    )\n  }\n\n  /**\n   * Gets countries by country code\n   * @param search - Country code\n   * @param query  - Query\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of country results with the name of the station and station count\n   */\n  async getCountryCodes(\n    search?: string,\n    query?: Query,\n    fetchConfig?: RequestInit\n  ): Promise<CountryResult[]> {\n    search = search ? `${search.toUpperCase()}` : ''\n\n    return this.runRequest(\n      this.buildRequest('countrycodes', search, query),\n      fetchConfig\n    )\n  }\n\n  /**\n   * Gets available codes\n   * @param query - Query\n   * @param fetchConfig -  Fetch configuration\n   * @returns List of available codes\n   */\n  async getCodecs(\n    query?: Query,\n    fetchConfig?: RequestInit\n  ): Promise<CountryResult[]> {\n    return this.runRequest(this.buildRequest('codecs', '', query), fetchConfig)\n  }\n\n  /**\n   * Gets country states. States **should** be regions inside a country.\n   * @param country - Limit state to particular country\n   * @param query - Query\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of country states\n   */\n  async getCountryStates(\n    country?: string,\n    query?: Query,\n    fetchConfig?: RequestInit\n  ): Promise<CountryStateResult[]> {\n    return this.runRequest(\n      this.buildRequest('states', country, query),\n      fetchConfig\n    )\n  }\n\n  /**\n   * Gets all available languages\n   * @param language- Limit results to particular language\n   * @param query -  Query\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of language results\n   */\n  async getLanguages(\n    language?: string,\n    query?: Query,\n    fetchConfig?: RequestInit\n  ): Promise<CountryResult[]> {\n    return this.runRequest(\n      this.buildRequest('languages', language, query),\n      fetchConfig\n    )\n  }\n\n  /**\n   * Gets all available tags\n   * @param tag - Limit results to particular tag\n   * @param query - Query\n   * @param fetchConfig - Fetch configuration\n   * @returns List of tag results\n   */\n  async getTags(\n    tag?: string,\n    query?: Query,\n    fetchConfig?: RequestInit\n  ): Promise<TagResult[]> {\n    tag = tag ? tag.toLowerCase() : '' // empty string returns all tags\n\n    return this.runRequest(this.buildRequest('tags', tag, query), fetchConfig)\n  }\n\n  /**\n   * Gets stations by various available parameters\n   * @param searchType - Parameter for the search\n   * @param search - Search value for the parameter\n   * @param query - Query\n   * @param fetchConfig - Fetch configuration\n   * @param removeDuplicates - remove duplicate stations\n   * @returns Array of station results\n   */\n  async getStationsBy(\n    searchType: keyof typeof StationSearchType,\n    search?: string,\n    query?: StationQuery,\n    fetchConfig?: RequestInit,\n    removeDuplicates = false\n  ): Promise<Station[]> {\n    if (!StationSearchType[searchType]) {\n      throw new Error(`search type does not exist: ${searchType}`)\n    }\n\n    search = search ? search.toLowerCase() : ''\n\n    // http://fr1.api.radio-browser.info/{format}/stations/byuuid/{searchterm}\n    const stations = await this.runRequest<StationResponse[]>(\n      this.buildRequest(`stations/${searchType.toLowerCase()}`, search, query),\n      fetchConfig\n    )\n\n    return this.normalizeStations(stations, removeDuplicates)\n  }\n\n  /**\n   * Normalizes stations from the API response\n   * @param stations - Array of station responses\n   * @param removeDuplicates - remove duplicate stations\n   * @returns Array of normalized stations\n   */\n  protected normalizeStations(\n    stations: StationResponse[],\n    removeDuplicates = false\n  ): Station[] {\n    const result = []\n    const duplicates: { [key: string]: boolean } = {}\n\n    for (const response of stations) {\n      if (removeDuplicates) {\n        const nameAndUrl = `${response.name.toLowerCase().trim()}${response.url\n          .toLowerCase()\n          .trim()}`\n\n        // guard against results having the same stations under different id's\n        if (duplicates[nameAndUrl]) continue\n\n        duplicates[nameAndUrl] = true\n      }\n\n      const station: Station = {\n        changeId: response.changeuuid,\n        id: response.stationuuid,\n        name: response.name,\n        url: response.url,\n        urlResolved: response.url_resolved,\n        homepage: response.homepage,\n        favicon: response.favicon,\n        country: response.country,\n        countryCode: response.countrycode,\n        state: response.state,\n        votes: response.votes,\n        codec: response.codec,\n        bitrate: response.bitrate,\n        clickCount: response.clickcount,\n        clickTrend: response.clicktrend,\n        hls: Boolean(response.hls),\n        lastCheckOk: Boolean(response.lastcheckok),\n        lastChangeTime: new Date(response.lastchangetime),\n        lastCheckOkTime: new Date(response.lastcheckoktime),\n        clickTimestamp: new Date(response.clicktimestamp),\n        lastLocalCheckTime: new Date(response.lastlocalchecktime),\n        language: response.language.split(','),\n        lastCheckTime: new Date(response.lastchecktime),\n        geoLat: response.geo_lat,\n        geoLong: response.geo_long,\n        tags: Array.from(new Set(response.tags.split(','))).filter(\n          (tag) => tag.length > 0 && tag.length < 10\n        ) // drop duplicates and tags over 10 characters\n      }\n\n      result.push(station)\n    }\n\n    return result\n  }\n\n  /**\n   * Gets all available stations. Please note that if results\n   * are not limited somehow, they can be huge (size in MB)\n   * @param query - Query\n   * @param fetchConfig - Fetch configuration\n   * @param removeDuplicates - remove duplicate stations\n   * @returns Array of all available stations\n   */\n  async getAllStations(\n    query?: Omit<StationQuery, 'hidebroken'>,\n    fetchConfig?: RequestInit,\n    removeDuplicates = false\n  ): Promise<Station[]> {\n    const stations = await this.runRequest<StationResponse[]>(\n      this.buildRequest('stations', '', query),\n      fetchConfig\n    )\n\n    return this.normalizeStations(stations, removeDuplicates)\n  }\n\n  /**\n   * Searches stations by particular params\n   * @param query - Query\n   * @param fetchConfig - Fetch configuration\n   * @param removeDuplicates - remove duplicate stations\n   * @returns Array of station results\n   */\n  async searchStations(\n    query: AdvancedStationQuery,\n    fetchConfig?: RequestInit,\n    removeDuplicates = false\n  ): Promise<Station[]> {\n    const stations = await this.runRequest<StationResponse[]>(\n      this.buildRequest('stations/search', undefined, query),\n      fetchConfig\n    )\n\n    return this.normalizeStations(stations, removeDuplicates)\n  }\n\n  /**\n   * Gets stations by clicks. Stations with the highest number of clicks are most popular\n   * @param limit - Limit the number of returned stations\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of stations\n   */\n  async getStationsByClicks(\n    limit?: number,\n    fetchConfig?: RequestInit\n  ): Promise<Station[]> {\n    return this.resolveGetStations('topclick', limit, fetchConfig)\n  }\n\n  /**\n   * Gets stations by votes. Returns most voted stations\n   * @param limit - Limit the number of returned stations\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of stations\n   */\n  async getStationsByVotes(\n    limit?: number,\n    fetchConfig?: RequestInit\n  ): Promise<Station[]> {\n    return this.resolveGetStations('topvote', limit, fetchConfig)\n  }\n\n  /**\n   * Gets stations by recent clicks. They are basically most recently listened stations.\n   * @param limit - Limit the number of returned stations\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of stations\n   */\n  async getStationsByRecentClicks(\n    limit?: number,\n    fetchConfig?: RequestInit\n  ): Promise<Station[]> {\n    return this.resolveGetStations('lastclick', limit, fetchConfig)\n  }\n\n  /**\n   * Sends click for the station. This method should be used when user starts to listen to the station.\n   * @param id - Station id\n   * @param fetchConfig  - Fetch configuration\n   * @returns Station click object\n   */\n  async sendStationClick(\n    id: string,\n    fetchConfig?: RequestInit\n  ): Promise<{\n    ok: boolean\n    message: string\n    stationuuid: string\n    name: string\n    url: string\n  }> {\n    return this.runRequest(\n      this.buildRequest('url', id, undefined, false),\n      fetchConfig\n    )\n  }\n\n  /**\n   * Votes for station. This method should be used when user adds the station to favourites etc..\n   * @param id - Station id\n   * @param fetchConfig - Fetch configuration\n   * @returns Station vote object\n   */\n  async voteForStation(\n    id: string,\n    fetchConfig?: RequestInit\n  ): Promise<{\n    ok: boolean\n    message: string\n    stationuuid: string\n    name: string\n    url: string\n  }> {\n    return this.runRequest(this.buildRequest('vote', id), fetchConfig)\n  }\n\n  /**\n   * Gets stations by station id\n   * @param ids - Array of station id's\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of stations\n   */\n  async getStationsById(\n    ids: string[],\n    fetchConfig?: RequestInit\n  ): Promise<Station[]> {\n    const stationsIds = ids.join(',')\n    const stations = await this.runRequest<StationResponse[]>(\n      this.buildRequest(\n        `stations/byuuid?uuids=${stationsIds}`,\n        undefined,\n        undefined,\n        false\n      ),\n      fetchConfig\n    )\n\n    return this.normalizeStations(stations)\n  }\n\n  /**\n   * Gets station by station url\n   * @param url - Station url\n   * @param fetchConfig - Fetch configuration\n   * @returns Array of stations\n   */\n  async getStationByUrl(\n    url: string,\n    fetchConfig?: RequestInit\n  ): Promise<Station[]> {\n    const stations = await this.runRequest<StationResponse[]>(\n      this.buildRequest(\n        `stations/byurl?url=${url}`,\n        undefined,\n        undefined,\n        false\n      ),\n      fetchConfig\n    )\n\n    return this.normalizeStations(stations)\n  }\n\n  protected async resolveGetStations(\n    endPoint: string,\n    limit?: number,\n    fetchConfig?: RequestInit\n  ): Promise<Station[]> {\n    const limitStations = limit ? `/${limit}` : ''\n    const stations = await this.runRequest<StationResponse[]>(\n      this.buildRequest(\n        `stations/${endPoint}${limitStations}`,\n        undefined,\n        undefined,\n        false\n      ),\n      fetchConfig\n    )\n\n    return this.normalizeStations(stations)\n  }\n\n  /**\n   * Builds request to the API\n   * @param endPoint - API endpoint\n   * @param search - Search term\n   * @param query - Query\n   * @param addHideBrokenParam - Hide broken stations from the results\n   * @returns Built request string\n   */\n  protected buildRequest(\n    endPoint: string,\n    search?: string,\n    query?: Query | AdvancedStationQuery | StationQuery,\n    addHideBrokenParam = true\n  ): string {\n    search = search ? `/${encodeURIComponent(search)}` : ''\n\n    let queryCopy\n    if (query) {\n      queryCopy = { ...query }\n      if ('tagList' in queryCopy && Array.isArray(queryCopy.tagList)) {\n        queryCopy.tagList = [...queryCopy.tagList]\n      }\n      if (addHideBrokenParam && queryCopy.hideBroken === undefined) {\n        queryCopy.hideBroken = this.hideBroken\n      }\n    }\n\n    const queryParams = queryCopy ? this.createQueryParams(queryCopy) : ''\n\n    return `${endPoint}${search}${queryParams}`\n  }\n\n  /**\n   * Fires of the request to the API\n   * @param url - Request url\n   * @param fetchConfig - Fetch configuration\n   * @returns Fetch response\n   */\n  protected async runRequest<T>(\n    url: string,\n    fetchConfig: RequestInit = {}\n  ): Promise<T> {\n    const finalConfig = {\n      ...this.fetchConfig,\n      ...fetchConfig,\n      headers: {\n        ...this.fetchConfig.headers,\n        ...fetchConfig.headers\n      }\n    }\n\n    if (!this.baseUrl) {\n      const results = await this.resolveBaseUrl()\n      const random = Math.floor(Math.random() * results.length)\n      this.baseUrl = `https://${results[random].name}`\n    }\n\n    const response = await fetch(`${this.baseUrl}/json/${url}`, finalConfig)\n\n    if (response.ok) {\n      return response.json()\n    } else {\n      throw response\n    }\n  }\n\n  /**\n   * Encodes query parameters\n   * @param params - Object that represents paramters as key value pairs\n   * @returns  String of encoded query parameters\n   */\n  protected createQueryParams(params?: object): string {\n    let result = ''\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        let finalKey = key.toLowerCase()\n\n        switch (finalKey) {\n          case 'hasgeoinfo':\n            finalKey = 'has_geo_info'\n            break\n          case 'hidebroken':\n            finalKey = 'hidebroken'\n            break\n\n          case 'taglist':\n            // github.com/segler-alex/radiobrowser-api-rust/issues/80\n            finalKey = 'tagList' // tagList is the only one that is not lowercased\n        }\n\n        result += `&${finalKey}=${encodeURIComponent(value)}`\n      }\n    }\n\n    return result.length ? `?${result.slice(1)}` : ''\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;AAGa,IAAAA,IAAqB,EAChCC,MAAM,QACNC,KAAK,OACLC,UAAU,YACVC,SAAS,WACTC,MAAM,QACNC,SAAS,WACTC,OAAO,SACPC,UAAU,YACVC,OAAO,SACPC,OAAO,SACPC,SAAS,WACTC,aAAa,eACbC,eAAe,iBACfC,gBAAgB,kBAChBC,YAAY,cACZC,YAAY,cACZC,QAAQ,SAAA;AAjBG,IAuBAC,IAAoB,EAC/BC,QAAQ,UACRC,QAAQ,UACRC,aAAa,eACbC,SAAS,WACTC,cAAc,gBACdC,WAAW,aACXC,gBAAgB,kBAChBC,oBAAoB,sBACpBC,SAAS,WACTC,cAAc,gBACdC,YAAY,cACZC,iBAAiB,mBACjBC,OAAO,SACPC,YAAY,aAAA;AAAA,ICxBDC,IDwBC,MCxBDA;EAeXC,YAAsBC,IAA2BC,KAAAA,MAAa;AAC5D,QADgEC,KAA5CF,UAAAA,QAA2BC,KAAAA,aAAAA,QAZvCE,KAAAA,UAAAA,QAAAA,KAEAC,cAA2B,EACnCC,QAAQ,OACRC,UAAU,SAAA,GAQUJ,KAAOF,UAAPA,IAA2BE,KAAUD,aAAVA,IAAAA,CAC1CD,GACH,OAAM,IAAIO,MAAM,qBAAA;AAElBL,SAAKE,YAAYI,UAAU,EAAE,cAAcN,KAAKF,QAAAA;EAClD;EAQA,MAAA,eACES,KAAsB,CAAE,GAAA;AAExB,QAAIC;AAQJ,UAAMC,KAAAA,MAAiBC,MAErB,kDACAH,EAAAA;AAEF,QAAIE,GAASE,GAGX,QAFAH,KAAAA,MAAeC,GAASG,KAAAA,GAEjBJ;AAEP,UAAMC;EAEV;EAMAI,WAAWhD,IAAAA;AACTmC,SAAKC,UAAUpC;EACjB;EAMAiD,aAAAA;AACE,WAAWd,KAACC;EACd;EASA,MAAA,aACEc,IACAC,IACAd,IAAAA;AAEA,WAAA,KAAYe,WACVjB,KAAKkB,aAAa,aAAaH,IAAQC,EAAAA,GACvCd,EAAAA;EAEJ;EASA,MAAA,gBACEa,IACAC,IACAd,IAAAA;AAIA,WAFAa,KAASA,KAAS,GAAGA,GAAOI,YAAAA,CAAAA,KAAkB,IAEnCnB,KAACiB,WACVjB,KAAKkB,aAAa,gBAAgBH,IAAQC,EAAAA,GAC1Cd,EAAAA;EAEJ;EAQA,MAAA,UACEc,IACAd,IAAAA;AAEA,WAAA,KAAYe,WAAWjB,KAAKkB,aAAa,UAAU,IAAIF,EAAAA,GAAQd,EAAAA;EACjE;EASA,MAAA,iBACEjC,IACA+C,IACAd,IAAAA;AAEA,WAAWF,KAACiB,WACVjB,KAAKkB,aAAa,UAAUjD,IAAS+C,EAAAA,GACrCd,EAAAA;EAEJ;EASA,MAAA,aACE/B,IACA6C,IACAd,IAAAA;AAEA,WAAOF,KAAKiB,WACVjB,KAAKkB,aAAa,aAAa/C,IAAU6C,EAAAA,GACzCd,EAAAA;EAEJ;EASA,MAAA,QACEkB,IACAJ,IACAd,IAAAA;AAIA,WAFAkB,KAAMA,KAAMA,GAAIC,YAAAA,IAAgB,IAErBrB,KAACiB,WAAWjB,KAAKkB,aAAa,QAAQE,IAAKJ,EAAAA,GAAQd,EAAAA;EAChE;EAWA,MAAA,cACEoB,IACAP,IACAC,IACAd,GACAqB,IAAAA,OAAmB;AAEnB,QAAA,CAAK1C,EAAkByC,EAAAA,EACrB,OAAM,IAAIjB,MAAM,+BAA+BiB,EAAAA,EAAAA;AAGjDP,IAAAA,KAASA,KAASA,GAAOM,YAAAA,IAAgB;AAGzC,UAAMG,IAAAA,MAAiBxB,KAAKiB,WAC1BjB,KAAKkB,aAAa,YAAYI,GAAWD,YAAAA,CAAAA,IAAiBN,IAAQC,EAAAA,GAClEd,CAAAA;AAGF,WAAWF,KAACyB,kBAAkBD,GAAUD,CAAAA;EAC1C;EAQUE,kBACRD,IACAD,KAAAA,OAAmB;AAEnB,UAAMf,KAAS,CAAA,GACTkB,KAAyC,CAAA;AAE/C,eAAWjB,KAAYe,IAAU;AAC/B,UAAID,IAAkB;AACpB,cAAMI,KAAa,GAAGlB,EAAS7C,KAAKyD,YAAAA,EAAcO,KAAAA,CAAAA,GAASnB,EAAS5C,IACjEwD,YAAAA,EACAO,KAAAA,CAAAA;AAGH,YAAIF,GAAWC,EAAAA,EAAa;AAE5BD,QAAAA,GAAWC,EAAAA,IAAAA;MACZ;AAED,YAAME,KAAmB,EACvBC,UAAUrB,EAASsB,YACnBC,IAAIvB,EAASwB,aACbrE,MAAM6C,EAAS7C,MACfC,KAAK4C,EAAS5C,KACdqE,aAAazB,EAAS0B,cACtBrE,UAAU2C,EAAS3C,UACnBC,SAAS0C,EAAS1C,SAClBE,SAASwC,EAASxC,SAClBmE,aAAa3B,EAAS4B,aACtBnE,OAAOuC,EAASvC,OAChBE,OAAOqC,EAASrC,OAChBC,OAAOoC,EAASpC,OAChBC,SAASmC,EAASnC,SAClBI,YAAY+B,EAAS6B,YACrB3D,YAAY8B,EAAS8B,YACrBC,KAAKC,QAAQhC,EAAS+B,GAAAA,GACtBE,aAAaD,QAAQhC,EAASkC,WAAAA,GAC9BC,gBAAgB,IAAIC,KAAKpC,EAASqC,cAAAA,GAClCC,iBAAiB,IAAIF,KAAKpC,EAASuC,eAAAA,GACnCC,gBAAgB,IAAIJ,KAAKpC,EAASyC,cAAAA,GAClCC,oBAAoB,IAAIN,KAAKpC,EAAS2C,kBAAAA,GACtCjF,UAAUsC,EAAStC,SAASkF,MAAM,GAAA,GAClC7E,eAAe,IAAIqE,KAAKpC,EAAS6C,aAAAA,GACjCC,QAAQ9C,EAAS+C,SACjBC,SAAShD,EAASiD,UAClB1F,MAAM2F,MAAMC,KAAK,IAAIC,IAAIpD,EAASzC,KAAKqF,MAAM,GAAA,CAAA,CAAA,EAAOS,OACjD1C,CAAAA,OAAQA,GAAI2C,SAAS,KAAK3C,GAAI2C,SAAS,EAAA,EAAA;AAI5CvD,MAAAA,GAAOwD,KAAKnC,EAAAA;IACb;AAED,WAAOrB;EACT;EAUA,MAAA,eACEQ,IACAd,IACAqB,KAAAA,OAAmB;AAEnB,UAAMC,KAAAA,MAAiBxB,KAAKiB,WAC1BjB,KAAKkB,aAAa,YAAY,IAAIF,EAAAA,GAClCd,EAAAA;AAGF,WAAWF,KAACyB,kBAAkBD,IAAUD,EAAAA;EAC1C;EASA,MAAA,eACEP,IACAd,IACAqB,KAAAA,OAAmB;AAEnB,UAAMC,KAAAA,MAAiBxB,KAAKiB,WAC1BjB,KAAKkB,aAAa,mBAAA,QAA8BF,EAAAA,GAChDd,EAAAA;AAGF,WAAWF,KAACyB,kBAAkBD,IAAUD,EAAAA;EAC1C;EAQA,MAAA,oBACE0C,IACA/D,IAAAA;AAEA,WAAA,KAAYgE,mBAAmB,YAAYD,IAAO/D,EAAAA;EACpD;EAQA,MAAA,mBACE+D,IACA/D,IAAAA;AAEA,WAAWF,KAACkE,mBAAmB,WAAWD,IAAO/D,EAAAA;EACnD;EAQA,MAAA,0BACE+D,IACA/D,IAAAA;AAEA,WAAOF,KAAKkE,mBAAmB,aAAaD,IAAO/D,EAAAA;EACrD;EAQA,MAAA,iBACE8B,IACA9B,IAAAA;AAQA,WAAA,KAAYe,WACVjB,KAAKkB,aAAa,OAAOc,IAAAA,QAAImC,KAAW,GACxCjE,EAAAA;EAEJ;EAQA,MAAA,eACE8B,IACA9B,IAAAA;AAQA,WAAWF,KAACiB,WAAWjB,KAAKkB,aAAa,QAAQc,EAAAA,GAAK9B,EAAAA;EACxD;EAQA,MAAA,gBACEkE,IACAlE,IAAAA;AAEA,UAAMmE,KAAcD,GAAIE,KAAK,GAAA,GACvB9C,KAAAA,MAAiBxB,KAAKiB,WAC1BjB,KAAKkB,aACH,yBAAyBmD,EAAAA,IAAAA,QACzBF,QACAA,KACA,GAEFjE,EAAAA;AAGF,WAAOF,KAAKyB,kBAAkBD,EAAAA;EAChC;EAQA,MAAA,gBACE3D,IACAqC,IAAAA;AAEA,UAAMsB,KAAAA,MAAAA,KAAsBP,WAC1BjB,KAAKkB,aACH,sBAAsBrD,EAAAA,IAAAA,QACtBsG,QACAA,KACA,GAEFjE,EAAAA;AAGF,WAAA,KAAYuB,kBAAkBD,EAAAA;EAChC;EAEU,MAAA,mBACR+C,IACAN,IACA/D,IAAAA;AAEA,UAAMsE,KAAgBP,KAAQ,IAAIA,EAAAA,KAAU,IACtCzC,IAAAA,MAAAA,KAAsBP,WAC1BjB,KAAKkB,aACH,YAAYqD,EAAAA,GAAWC,EAAAA,IAAAA,QACvBL,QACAA,KACA,GAEFjE,EAAAA;AAGF,WAAOF,KAAKyB,kBAAkBD,CAAAA;EAChC;EAUUN,aACRqD,IACAxD,IACAC,IACAyD,IAAAA,MAAqB;AAIrB,QAAIC;AAaJ,WAfA3D,KAASA,KAAS,IAAI4D,mBAAmB5D,EAAAA,CAAAA,KAAY,IAGjDC,OACF0D,IAASE,EAAAA,CAAAA,GAAQ5D,EAAAA,GACb,aAAa0D,KAAaf,MAAMkB,QAAQH,EAAUI,OAAAA,MACpDJ,EAAUI,UAAU,CAAA,GAAIJ,EAAUI,OAAAA,IAEhCL,KAAAA,WAAsBC,EAAU3E,eAClC2E,EAAU3E,aAAaC,KAAKD,cAMzB,GAAGwE,EAAAA,GAAWxD,EAAAA,GAFD2D,IAAY1E,KAAK+E,kBAAkBL,CAAAA,IAAa,EAAA;EAGtE;EAQU,MAAA,WACR7G,IACAqC,KAA2B,CAAE,GAAA;AAE7B,UAAM8E,KAAWJ,EAAA,CAAA,GACZ5E,KAAKE,aACLA,IAAW,EACdI,SAAOsE,EACF,CAAA,GAAA5E,KAAKE,YAAYI,SACjBJ,GAAYI,OAAAA,EAAAA,CAAAA;AAInB,QAAA,CAAKN,KAAKC,SAAS;AACjB,YAAMgF,KAAAA,MAAAA,KAAqBC,eAAAA,GACrBtG,KAASuG,KAAKC,MAAMD,KAAKvG,OAAAA,IAAWqG,GAAQlB,MAAAA;AAClD/D,WAAKC,UAAU,WAAWgF,GAAQrG,EAAAA,EAAQhB,IAAAA;IAC3C;AAED,UAAM6C,IAAAA,MAAiBC,MAAM,GAAGV,KAAKC,OAAAA,SAAgBpC,EAAAA,IAAOmH,EAAAA;AAE5D,QAAIvE,EAASE,GACX,QAAOF,EAASG,KAAAA;AAEhB,UAAMH;EAEV;EAOUsE,kBAAkBM,IAAAA;AAC1B,QAAI7E,KAAS;AACb,QAAI6E,GACF,YAAK,CAAOC,IAAKC,EAAAA,KAAUC,OAAOC,QAAQJ,EAAAA,GAAS;AACjD,UAAIK,KAAWJ,GAAIjE,YAAAA;AAEnB,cAAQqE,IAAAA;QACN,KAAK;AACHA,UAAAA,KAAW;AACX;QACF,KAAK;AACHA,UAAAA,KAAW;AACX;QAEF,KAAK;AAEHA,UAAAA,KAAW;MAAA;AAGflF,MAAAA,MAAU,IAAIkF,EAAAA,IAAYf,mBAAmBY,EAAAA,CAAAA;IAC9C;AAGH,WAAO/E,GAAOuD,SAAS,IAAIvD,GAAOmF,MAAM,CAAA,CAAA,KAAO;EACjD;AAAA;AApiBW/F,EACJgG,UAAO;",
  "names": ["StationSearchOrder", "name", "url", "homepage", "favicon", "tags", "country", "state", "language", "votes", "codec", "bitrate", "lastCheckOK", "lastCheckTime", "clickTimeStamp", "clickCount", "clickTrend", "random", "StationSearchType", "byUuid", "byName", "byNameExact", "byCodec", "byCodexExact", "byCountry", "byCountryExact", "byCountryCodeExact", "byState", "byStateExact", "byLanguage", "byLanguageExact", "byTag", "byTagExact", "RadioBrowserApi", "constructor", "appName", "hideBroken", "this", "baseUrl", "fetchConfig", "method", "redirect", "Error", "headers", "config", "result", "response", "fetch", "ok", "json", "setBaseUrl", "getBaseUrl", "search", "query", "runRequest", "buildRequest", "toUpperCase", "tag", "toLowerCase", "searchType", "removeDuplicates", "stations", "normalizeStations", "duplicates", "nameAndUrl", "trim", "station", "changeId", "changeuuid", "id", "stationuuid", "urlResolved", "url_resolved", "countryCode", "countrycode", "clickcount", "clicktrend", "hls", "Boolean", "lastCheckOk", "lastcheckok", "lastChangeTime", "Date", "lastchangetime", "lastCheckOkTime", "lastcheckoktime", "clickTimestamp", "clicktimestamp", "lastLocalCheckTime", "lastlocalchecktime", "split", "lastchecktime", "geoLat", "geo_lat", "geoLong", "geo_long", "Array", "from", "Set", "filter", "length", "push", "limit", "resolveGetStations", "undefined", "ids", "stationsIds", "join", "endPoint", "limitStations", "addHideBrokenParam", "queryCopy", "encodeURIComponent", "_extends", "isArray", "tagList", "createQueryParams", "finalConfig", "results", "resolveBaseUrl", "Math", "floor", "params", "key", "value", "Object", "entries", "finalKey", "slice", "version"]
}
